+++
date = "2017-05-14"
title = "Machine Generated Music"

keywords = ["ai", "markov chains", "midi"]
categories = ["projects"]
+++

For my colleges Intro to AI class final project myself and another decided to explore composing music using machine learning. This is in no way a unique project. Others have done similar before. My favorite implementation I saw was this [program](https://aiexperiments.withgoogle.com/ai-duet) which uses neural networks to allow you to play a piano duet with the AI.

## Project Background:

Bitstream files such as MP3 and Wavs which store music as sine waves would be very difficult to use as the data is continuous and unlabeled. It would be virtually impossible to parse the information needed from these files.

Instead we used midi files. Midis are discrete and store data as events of pitch, velocity and location. From this we would be able to parse the data very easily. It also had the benefit of being an easy format for our system to compose music. We chose to use the [midi library python-midi](https://github.com/vishnubob/python-midi/).

## Machine Learning Theory:

Based on research we decided to use Markov chains for our implementation. Markov chains are on the simpler side of machine learning but haven been proven to be affective in AI music composition. Markov chains are a process created by Russian mathematician Andrey Markov. Markov chains look at the probability of moving from one state to another state. The benefit of Markov chains are they make their decision not off the full history of the state but the previous x number of states it took to get to the current state. How many states prior to the successor states you look at it called the order.

![Markov Visualization](https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Markovkate_01.svg/563px-Markovkate_01.svg.png)

This example is of order 1 as it is only looking at just one prior state.

For our project we implemented the Markov Class by hand to allow us to extend it where needed. For it's implementation it stored data a dictionary of transition states, which contained a dictionary of successor states and their occurrences. Because we planned to build Markov chains using a large source of [data](http://pianola.co.nz/public/index.php/web/zip_download), we built methods to store and retrieve the Markov chain as a JSON file. Our implementation could add each state transition at a speed of O(n) and could read each state transition at a speed of O(1). Because we used dictionaries there was amortized time as well.

```
//How our Markov chains were stored:
{
    "A": {
        "B": 12,
        "D": 4
    },
    "E": {
        F: 2,
        G: 10
    }
}
```

We were able to store both notes (whether a single chord or note) as well as rhythm transitions in the same Markov implementation. It would be possible to store both pieces of data in the same object but we chose not to (for simplicity and to reduce the possible number of states). Interestingly the JSON representation of our Markov Chain would grow larger than the source data. A Markov Chain file looking at pitch at an order of 2, sources from 73mb of data produced a Markov file of 109MB. On our basic Lenovo laptops this took 10 to 20 minutes to build.

## Composing:

The portion of our program that composed music from the Markov chains proved simple to build. It would randomly produce a list of notes of the same length as our Markov chains order. From there it would then loop grabbing a successor note based on the previous selected notes. If it ever reached a state where the transition state didnâ€™t exist in the Markov it would simply delete the previous note and try again. If it ever reached a length less than the Markov chain order It would generate the note randomly. Rhythm was generated identically.

Because the composer built the song using a rhythm and note Markov file, we were able to experiment mixing up methods. Most often, we chose to use a Markov file of rhythm of order 4 and pitch of order 2. We experimented also with using larger Markov files for pitch and smaller files for rhythm in an attempt to simplify the rhythm. Another way we attempted to simplify the rhythm was source the rhythm Markov from classical music and the pitches from our [ragtime files](http://pianola.co.nz/public/index.php/web/zip_download).

## Conclusion:

Although we were able to generate objectively good pitch transitions in our music, rhythm proved to be less suited for our Markov chains implementation. This is most likely due to rhythms having to follow a time signature and our source music existing in different time signatures. If we had more time we would have tried implementing Neural Networks in our composition (most of the most successful musical machine learning projects use such). 

Here is a quick piece of music generated by our program. As you can see the rhythm get's a bit wonky at the end.

<a href="http://www.youtube.com/watch?feature=player_embedded&v=bgaoaCo746M
" target="_blank"><img src="http://img.youtube.com/vi/bgaoaCo746M/0.jpg"
alt="IMAGE ALT TEXT HERE" width="240" height="180" border="10" /></a>
